<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="generator" content="Hugo 0.79.0" />


  <title>The trouble with &amp;lsquo;controlling for blocks&amp;rsquo; - DeclareDesign</title>




  









<link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css'>



<script defer src="https://use.fontawesome.com/releases/v5.5.0/js/all.js" integrity="sha384-GqVMZRt5Gn7tB9D9q7ONtcp4gtHIUEW/yG7h98J7IpE3kpi+srfFyyB/04OV6pG0" crossorigin="anonymous"></script>

<link href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,500,500i,700,700i" rel="stylesheet">

<link rel="stylesheet" href="/css/bootstrap.min.css">

<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>






  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="The trouble with &amp;lsquo;controlling for blocks&amp;rsquo;">
  <meta name="twitter:description" content='In many experiments, different groups of units get assigned to treatment with different probabilities. This can give rise to misleading results unless you properly take account of possible differences between the groups. How best to do this? The go-to approach is to “control” for groups by introducing “fixed-effects” in a regression set-up. The bad news is that this procedure is prone to bias. The good news is that there’s an even simpler and more intuitive approach that gets it right: estimate the difference-in-means within each group, then average over these group-level estimates weighting according to the size of the group. We’ll use design declaration to show the problem and to compare the performance of this and an array of other proposed solutions.

'>






<script src="/js/dropdown_menu.js"></script>
<link rel="stylesheet" href="/css/custom.css">

  </head>
  <body>
    <div class="wrapper">
      
        
<header>
  <div class="navbar-wrap fixed-top bg-white">
    <nav class="navbar navbar-expand-lg navbar-light">
      <div class="container-fluid"> <a class="navbar-brand" href="/"><img src="/images/brand.svg" alt=""></a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
          <ul class="navbar-nav ml-auto">
            <li class="nav-item"><a class="nav-link" href="/getting-started.html">Getting Started</a></li>
            <li class="nav-item"><a class="nav-link" href="/library.html">Library</a></li>
            <li class="nav-item dropdown">
              
              <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Software <b class="caret"></b></a>
              <ul class="dropdown-menu">
                <li><a class="dropdown-item" href="/r/declaredesign/">DeclareDesign</a></li>
                <li><a class="dropdown-item" href="/r/randomizr/">randomizr</a></li>
                <li><a class="dropdown-item" href="/r/fabricatr/">fabricatr</a></li>
                <li><a class="dropdown-item" href="/r/estimatr/">estimatr</a></li>
                <li><a class="dropdown-item" href="/r/designlibrary/">DesignLibrary</a></li>
              </ul>
            </li>
            <li class="nav-item"><a class="nav-link" href="/blog.html">Blog</a></li>
            <li class="nav-item"><a class="nav-link" href="/about.html">About</a></li>
            <li class="nav-item"><a target="_blank" class="nav-link" href="http://discuss.declaredesign.org/">Help</a></li>
          </ul>
        </div>
      </div>
    </nav>
  </div>
</header>

 

      


<main class="container">
  <div class="row justify-content-between">
    <div class="col-lg-12" id="content_column">
      <article class="article">

        <a class="h1 d-block mb-3" href="/blog">DeclareDesign Blog</a>
        <h2 class="article-title">The trouble with &lsquo;controlling for blocks&rsquo;</h2>

        
        <span class="article-date">2018/10/09</span>
        

        <div class="article-content">
          
<link href="/rmarkdown-libs/anchor-sections/anchor-sections.css" rel="stylesheet" />
<script src="/rmarkdown-libs/anchor-sections/anchor-sections.js"></script>


<p>In many experiments, different groups of units get assigned to treatment with different probabilities. This can give rise to misleading results unless you properly take account of possible differences between the groups. How best to do this? The go-to approach is to “control” for groups by introducing “fixed-effects” in a regression set-up. The bad news is that this procedure is prone to bias. The good news is that there’s an even simpler and more intuitive approach that gets it right: estimate the difference-in-means within each group, then average over these group-level estimates weighting according to the size of the group. We’ll use design declaration to show the problem and to compare the performance of this and an array of other proposed solutions.</p>
<div id="the-trouble" class="section level1">
<h1>The trouble</h1>
<p>For intuition, imagine a design that has experimental blocks (these might correspond to geographic regions or gender groups, for example). In block A, we treat 1/3 of the units and in block B, we treat 1/2. We are interested in an outcome <span class="math inline">\(Y\)</span>, income, for example. We worry though that if income is higher in group B than group A that we will have introduced a correlation between treatment and outcomes even if there is no causal effect of treatment on income. We want to avoid that kind of false inference.</p>
<p>A good way to think about the problem is to recognize that the overall average treatment effect can be thought of as an average of the average treatment effects in each block. Luckily, figuring out the average effect within a block is not hard. We can think of each block as its own mini-experiment. Within each block all units are treated with the same probability and so difference-in-means estimation <em>within</em> a block works fine to get at the average effect for units in that block. In order to get an overall ATE estimate, we then just have to average the block level estimates together. So if we weight the within-group effects together by <span class="math inline">\(n_j\)</span> (the size of block <span class="math inline">\(j\)</span>), we have an unbiased estimator of the ATE.</p>
<p>Simple enough.</p>
<p>But in practice researchers often try to do this calculation using “block fixed effects,” i.e., include a set of block dummies in a regression of the outcome on treatment assignment. The problem though is that while fixed-effects regression does average across within-block average effects, it does so using the wrong weighting scheme. The regression weights are <span class="math inline">\(p_j(1-p_j)n_j\)</span>, where share <span class="math inline">\(p_j\)</span> of <span class="math inline">\(n_j\)</span> units are treated within block <span class="math inline">\(j\)</span>. Fixed-effects OLS essentially puts more weight on the blocks with the greatest variance in the treatment variable.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p>
<p>Let’s demonstrate the issue using DeclareDesign and then move on to examining different solutions.</p>
<p>First, we declare a design that has three equally-sized blocks, with block-specific effects (<code>tau</code>) and assignment probabilities (<code>prob</code>). We will use three answer strategies: simple regression of the outcome on the treatment indicator (Naive Pooled), a regression of the outcome on the treatment indicator and block fixed effects (Least Squares Dummy Variables), and a sample-weighted average of the within-block difference-in-means (Blocked DIM). We will use a design where the noise is quite small relative to the error to clarify that that the problem is not about precision.</p>
<p>Here’s the design declaration:</p>
<pre class="r"><code># Model ------------------------------------------------------------------------
U &lt;- declare_population(block = add_level(N = 3,
                                          prob = c(.5, .7, .9),
                                          tau = c(4, 2, 0)),
                        indiv = add_level(N = 100, e = rnorm(N)))

Y &lt;- declare_potential_outcomes(Y_Z_0 = e,
                                Y_Z_1 = e + tau)

# Inquiry ----------------------------------------------------------------------
Q &lt;- declare_estimand(ATE = mean(Y_Z_1 - Y_Z_0))

# Data Strategy ----------------------------------------------------------------
Z &lt;- declare_assignment(blocks = block, block_prob = c(.5, .7, .9))
R &lt;- declare_reveal(Y, Z)

# Answer Strategy --------------------------------------------------------------
A0 &lt;- declare_estimator(Y ~ Z, estimand = Q,  
                        model =  lm_robust, label = &quot;A0: Naive (Pooled)&quot;)
A1 &lt;- declare_estimator(Y ~ Z + block, estimand = Q,  
                        model =  lm_robust, label = &quot;A1: LSDV&quot;)
A2 &lt;- declare_estimator(Y ~ Z, blocks = block, estimand = Q,  
                        model =  difference_in_means, label = &quot;A2: Blocked DIM&quot;)

# Design -----------------------------------------------------------------------
design &lt;- U + Y + Z + Q + R + A0 + A1 + A2</code></pre>
<p>Diagnosis of this design lets us see how these different strategies perform:</p>
<pre class="r"><code>diagnose_design(design, sims = sims)</code></pre>
<table style="width:100%;">
<colgroup>
<col width="16%" />
<col width="5%" />
<col width="4%" />
<col width="5%" />
<col width="8%" />
<col width="12%" />
<col width="10%" />
<col width="7%" />
<col width="10%" />
<col width="12%" />
<col width="6%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Estimator Label</th>
<th align="left">Bias</th>
<th align="left">RMSE</th>
<th align="left">Power</th>
<th align="left">Coverage</th>
<th align="left">Mean Estimate</th>
<th align="left">SD Estimate</th>
<th align="left">Mean Se</th>
<th align="left">Type S Rate</th>
<th align="left">Mean Estimand</th>
<th align="right">N Sims</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">A0: Naive (Pooled)</td>
<td align="left">-0.38</td>
<td align="left">0.40</td>
<td align="left">1.00</td>
<td align="left">0.33</td>
<td align="left">1.62</td>
<td align="left">0.13</td>
<td align="left">0.17</td>
<td align="left">0.00</td>
<td align="left">2.00</td>
<td align="right">10000</td>
</tr>
<tr class="even">
<td align="left">A1: LSDV</td>
<td align="left">0.58</td>
<td align="left">0.59</td>
<td align="left">1.00</td>
<td align="left">0.08</td>
<td align="left">2.58</td>
<td align="left">0.13</td>
<td align="left">0.20</td>
<td align="left">0.00</td>
<td align="left">2.00</td>
<td align="right">10000</td>
</tr>
<tr class="odd">
<td align="left">A2: Blocked DIM</td>
<td align="left">-0.00</td>
<td align="left">0.15</td>
<td align="left">1.00</td>
<td align="left">0.94</td>
<td align="left">2.00</td>
<td align="left">0.15</td>
<td align="left">0.15</td>
<td align="left">0.00</td>
<td align="left">2.00</td>
<td align="right">10000</td>
</tr>
</tbody>
</table>
<p>The difference-in-means approach does a good job of estimating the true average treatment effect in the sample. The two other approaches get it terribly wrong.</p>
<p>It’s easy enough to see why the pooled estimator gets things wrong. In this design, the blocks with bigger treatment probabilities also have smaller outcomes in the treatment condition. This creates a negative relation between treatment and outcomes that pulls down the estimate of effects.</p>
<p>But, oddly, the fixed effects estimators is not just biased, it is biased in the opposite direction of the bias of the pooled estimator. Why is that?</p>
</div>
<div id="why-do-fixed-effects-get-it-wrong" class="section level1">
<h1>Why do fixed effects get it wrong?</h1>
<p>We can use the design to drill down and see where this bias from the fixed effects estimator is coming from. We will use the design to generate simulated data and to run our estimators on that single draw.<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a></p>
<pre class="r"><code>one_draw &lt;- draw_data(design)
A1(one_draw)
A2(one_draw)</code></pre>
<table>
<thead>
<tr class="header">
<th align="left">estimator_label</th>
<th align="right">estimate</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">A1: LSDV</td>
<td align="right">2.533</td>
</tr>
<tr class="even">
<td align="left">A2: Blocked DIM</td>
<td align="right">1.951</td>
</tr>
</tbody>
</table>
<p>With this simulated data we can calculate the within block effects and the block weights “by hand” to see how the differences-in-means approach and the fixed effects approach do things differently. For this we use <code>dplyr</code> functionality which makes it easy to operate within multiple blocks in parallel.</p>
<pre class="r"><code>within_block &lt;-
  one_draw %&gt;%
  group_by(block) %&gt;%
  summarise(block_ATE     = mean(Y_Z_1 - Y_Z_0),
            block_ATE_est = mean(Y[Z == 1]) - mean(Y[Z == 0]),
            n_j = n(),
            p_j = mean(Z),
            sample_weight = n_j,
            fe_weight     = p_j * (1 - p_j) * n_j) %&gt;%
  # divide by the sum of the weights
  mutate(sample_weight = sample_weight/sum(sample_weight),
         fe_weight = fe_weight/sum(fe_weight))</code></pre>
<pre><code>## `summarise()` ungrouping output (override with `.groups` argument)</code></pre>
<table>
<thead>
<tr class="header">
<th align="left">block</th>
<th align="right">block_ATE</th>
<th align="right">block_ATE_est</th>
<th align="right">n_j</th>
<th align="right">p_j</th>
<th align="right">sample_weight</th>
<th align="right">fe_weight</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="right">4</td>
<td align="right">4.17</td>
<td align="right">100</td>
<td align="right">0.5</td>
<td align="right">0.33</td>
<td align="right">0.45</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="right">2</td>
<td align="right">1.66</td>
<td align="right">100</td>
<td align="right">0.7</td>
<td align="right">0.33</td>
<td align="right">0.38</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="right">0</td>
<td align="right">0.02</td>
<td align="right">100</td>
<td align="right">0.9</td>
<td align="right">0.33</td>
<td align="right">0.16</td>
</tr>
</tbody>
</table>
<p>This table helps explain the bias: one-third of the sample has an ATE estimate of 4.17, one-third has an ATE estimate of 1.66, and one-third an estimate of 0.02. Yet, the fixed effects estimator attributes those block-level estimated effects weights of 45%, 38%, and 16%, respectively: it exaggerates the true average effect by overweighting blocks with large effects and underweighting blocks with small effects.</p>
<p>To finish the example, see that we can recover the fixed effects and block DIM estimates from the within block estimates, just by choosing a different weighting strategy.</p>
<pre class="r"><code>within_block %&gt;%
  summarize(LDSV = weighted.mean(block_ATE_est, fe_weight),
            Blocked_DIM = weighted.mean(block_ATE_est, sample_weight))</code></pre>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="right">Estimate</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">LSDV</td>
<td align="right">2.533</td>
</tr>
<tr class="even">
<td align="left">Blocked_DIM</td>
<td align="right">1.951</td>
</tr>
</tbody>
</table>
</div>
<div id="a-horserace-between-different-approaches" class="section level1">
<h1>A horserace between different approaches</h1>
<p>In addition to block-wise difference-in-means, there are many other solutions that have been proposed to the problem outlined above. One might use a saturated regression <span class="citation">(Lin 2013)</span>, inverse propensity-weighted (IPW) regression, IPW with fixed effects, fixed effects regression with units reweighted by the inverse variance of assignment in their block, or a Horvitz-Thompson estimator. A recent contribution by <span class="citation">Gibbons, Serrato, and Urbancic (2018)</span> suggests two new estimators (“interaction-weighted” and “regression-weighted” estimators) and provides a package to estimate them (<code>bfe</code>).</p>
<p>Less clear, however, is how these different approaches compare against each other.</p>
<p>We can address this question for any design using design diagnosis. We add the different estimation approaches to our design:</p>
<pre class="r"><code>A3 &lt;- declare_estimator(Y ~ Z, covariates = ~ block, estimand = Q,
                        model = lm_lin,
                        label = &quot;A3: Interaction (Lin)&quot;)
A4 &lt;- declare_estimator(Y ~ Z, estimand = Q,
                        model = lm_robust, weight = 1/Z_cond_prob,
                        label = &quot;A4: IPW&quot;)
A5 &lt;- declare_estimator(Y ~ Z, fixed_effects = ~block, estimand = Q,
                        model = lm_robust, weight = 1/Z_cond_prob,
                        label = &quot;A5: IPW + FE&quot;)
A6 &lt;- declare_estimator(Y ~ Z, fixed_effects = ~block, estimand = Q,
                        model = lm_robust, weight = 1/(Z_cond_prob*(1-Z_cond_prob)),
                        label = &quot;A6: Var weight + FE&quot;)
A7 &lt;- declare_estimator(Y ~ Z, estimand = Q, blocks = block, simple = FALSE,
                        model = horvitz_thompson, condition_prs = prob,
                        label = &quot;A7: Horvitz-Thompson&quot;)
IWE &lt;- function(data) {
          M &lt;- EstimateIWE(&quot;Y&quot;, &quot;Z&quot;, &quot;block&quot;, controls = NULL, data = data)
          data.frame(term = &quot;Z&quot; ,estimate = M$swe.est, std.error = M$swe.var^.5)}

RWE &lt;- function(data) {
          M &lt;- EstimateRWE(&quot;Y&quot;, &quot;Z&quot;, &quot;block&quot;, controls = NULL, data = data)
          data.frame(term = &quot;Z&quot;, estimate = M$swe.est, std.error = M$swe.var^.5)}

A8 &lt;- declare_estimator(handler = label_estimator(IWE), estimand = Q,
                        label = &quot;A8: IWE&quot;)
A9 &lt;- declare_estimator(handler = label_estimator(RWE), estimand = Q,
                        label = &quot;A9: RWE&quot;)

# Augmented Design ---------------------------------------------------------------

design &lt;- design + A3 + A4 + A5 + A6 + A7 #+ A8 + A9</code></pre>
<p>And we can then simulate and plot the estimates:</p>
<pre class="r"><code>simulations &lt;- simulate_design(design,sims = sims)</code></pre>
<pre class="r"><code>simulations %&gt;%
  group_by(estimator_label) %&gt;%
  summarize(SE_bias = mean(std.error - sd(estimate)),
            ATE_bias = mean(estimate - estimand), .groups = &quot;drop&quot;) %&gt;%
  ggplot(aes(x = ATE_bias, y = SE_bias)) +
  geom_point() +
  geom_hline(yintercept = 0, size = .1, linetype = &quot;dashed&quot;) +
  geom_vline(xintercept = 0, size = .1, linetype = &quot;dashed&quot;) +
  geom_text_repel(aes(label = estimator_label), box.padding = .65,
                  point.padding = .5, segment.alpha = .5)</code></pre>
<p><img src="/blog/2018-10-09-biased_fixed_effects_files/figure-html/unnamed-chunk-16-1.png" width="672" /></p>
<p>Interestingly, the largest differences between the approaches appear to arise from the way in which they calculate the standard error. A great thing about design diagnosis is that one can assess the performance not just of estimates but also of standard errors. We use standard errors as a measure of the standard deviation of the estimates under repeated experiments. This is a quantity we have access to from simulation and so for each approach we can compare the estimated standard error to the standard deviation of the sampling distribution of effects.</p>
<p>We see that many approaches appear overly conservative – particularly the weighting approaches, though one approach estimates, on average, a standard error that is marginally smaller than the real standard deviation of the sampling distribution of estimated effects.</p>
<p>In terms of estimates, however, there are no real differences in performance between approaches 2-9. The block-specific difference-in-means approach has the merit of conceptual simplicity and great performance. The IPW and Horvitz-Thompson approaches have the advantage that they can be used even if the heterogeneity in assignment propensities is at the unit-level, and not at the block-level. And regression-based approaches have the merit of making it simple to condition on available covariates.</p>
</div>
<div id="this-issue-is-surprisingly-common" class="section level1">
<h1>This issue is surprisingly common</h1>
<p>Many designs face this issue, where assignment propensities are different in different groups. Often the issue might not be immediately apparent. Some examples:</p>
<ul>
<li>Subjects are randomly matched to play a game and you are interested in assessing the difference in play between single gender and mixed gender pairings. There are different numbers of men and women in the group.</li>
<li>A random set of children in a school are given some treatment and you are interested in seeing the effects on siblings of having another sibling treated. Families are of different sizes.</li>
<li>One village in each parish is selected for a treatment. But parishes are of different sizes.
<!-- * Countries have a reform at different points in a time series. You want to estimate the generalized difference-in-differences between countries that have or have not yet had the reform (See: @goodmanbackon2018). --></li>
</ul>
<p>In all these cases there is what looks at first glance to be equal assignment propensities across units but on closer inspection assignment propensities in fact depend on group size in some way.</p>
<p>See <span class="citation">Gibbons, Serrato, and Urbancic (2018)</span> for many examples in economics research and assessments of the implications of ignoring this issue.</p>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references">
<div id="ref-angrist1998estimating">
<p>Angrist, Joshua D. 1998. “Estimating the Labor Market Impact of Voluntary Military Service Using Social Security Data on Military Applicants.” <em>Econometrica</em> 66 (2): 249–88.</p>
</div>
<div id="ref-gibbons2014broken">
<p>Gibbons, Charles E, Juan Carlos Suárez Serrato, and Michael B Urbancic. 2018. “Broken or Fixed Effects?” <em>Journal of Econometric Methods</em>.</p>
</div>
<div id="ref-lin2013agnostic">
<p>Lin, Winston. 2013. “Agnostic Notes on Regression Adjustments to Experimental Data: Reexamining Freedman’s Critique.” <em>The Annals of Applied Statistics</em> 7 (1): 295–318.</p>
</div>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>This is a well known problem. See, for instance, <span class="citation">Angrist (1998)</span>.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>Functions in <code>DeclareDesign</code> create functions that take dataframes and return dataframes or statistics. Thus, we could also have taken one draw of the data using <code>one_draw &lt;- U() %&gt;% Y %&gt;% Z %&gt;% R</code>. The first five variables were created by <code>U()</code>: <code>block</code> indicates the block to which the unit belongs, <code>prob</code> indicates the probability of assignment to treatment, <code>tau</code> indicates the block-level treatment effect, <code>indiv</code> indicates the individual ID, and <code>e</code> is the error term. The function <code>Y()</code> appends the potential outcomes, <code>Y_Z_0</code> and <code>Y_Z_1</code>, by taking <code>e</code> and adding <code>tau</code> in treatment. The function <code>Z()</code> appends two variables: <code>Z</code> is a vector of treatment assignments, block-randomized as a function of the block probabilities, while <code>Z_cond_prob</code> indicates the probability that a given unit is observed in the condition to which they were actually assigned. <code>R()</code> reveals the potential outcomes corresponding to the assignment.<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
</ol>
</div>

        </div>
      </article>
      



    </div>
  </div>
</main>

    </div>

    

<footer>
    <div class="footer-top">
      <div class="container">
        <div class="row no-gutters">
          <div class="col-lg-7 col-md-12">
            <div class="row">
              <div class="col-md-3 col-12">
                <div class="footer-brand"><a href=""><img src="/images/brand-footer.svg" alt=""></a></div>
              </div>
              <div class="col-md-3 col-4">
                <p>DeclareDesign</p>
                <ul class="list-unstyled">
                  <li><a href="/">Home</a></li>
                  <li><a href="/about.html">About</a></li>
                  <li><a href="/r/designlibrary">Library</a></li>
                  <li><a href="/blog.html">Blog</a></li>
                  <li><a href="http://discuss.declaredesign.org/">Help</a></li>
                </ul>
              </div>
              <div class="col-md-3 col-4">
                <p>Software</p>
                <ul class="list-unstyled">
                  <li><a href="/r/declaredesign/">DeclareDesign</a></li>
                  <li><a href="/r/estimatr/">estimatr</a></li>
                  <li><a href="/r/randomizr/">randomizr</a></li>
                  <li><a href="/r/fabricatr/">fabricatr</a></li>
                  <li><a href="/r/designlibrary/">DesignLibrary</a></li>
                </ul>
              </div>
              
            </div>
          </div>
          <div class="col-lg-5 col-md-12"></div>
        </div>
      </div>
    </div>
    <div class="footer-bottom">
      <div class="footer-meta-block">
        <div class="container">
          <div class="row align-items-center">
            <div class="col-sm-7">
              <p class="mb-0">&copy; 2021 Graeme Blair, Jasper Cooper, Alexander Coppock, and Macartan Humphreys</p>
            </div>
            <div class="col-sm-5">
              <div class="fbl-link-wrap">
                <ul class="list-inline mb-0">
                  <li class="list-inline-item"> <a target="_blank" href="http://github.com/DeclareDesign/"><img src="images/icon-git.svg" alt=""></a> </li>
                </ul>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </footer>
  
   
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>

    <link rel="stylesheet" href="https://cdn.datatables.net/v/bs4/dt-1.10.18/datatables.min.css"/>
<script src="https://cdn.datatables.net/v/bs4/dt-1.10.18/datatables.min.js"></script>

<script>
    jQuery(function ()
    {
        const library_list = jQuery("#design_library_list");
        library_list.addClass("table table-striped table-bordered");
        library_list.DataTable(
            {
                "autoWidth": false,
                "columns":
                    [
                        {"width": "30%"}, 
                        {"width": "10%"}, 
                        {"width": "10%"}, 
                        {"width": "10%"}, 
                        {"width": "15%"}, 
                        {"width": "25%"}, 
                    ],
                "drawCallback": initialize_tooltips
            }
        );

        library_list.css("width", "");
    });

    function initialize_tooltips()
    {
        const tooltip_elements = jQuery('[data-toggle="tooltip"]');
        tooltip_elements.tooltip();
        tooltip_elements.click(function ()
        {
            jQuery(this).tooltip("hide");
        });
    }
</script>

    


<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>



<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/r.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
<script>
jQuery(function ()
{
  $('pre').each(function (index)
  {
    hljs.highlightBlock(this);
  });
});
</script>



    
<script src="/js/math-code.js"></script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


    



    
  </body>
</html>

